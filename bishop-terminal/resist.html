<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Resilience Stands</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Cormorant+Garamond:wght@300&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; background: #060d14; overflow: hidden; cursor: crosshair; }

  /* Main canvas fills the screen */
  #c { position: fixed; inset: 0; display: block; }

  /* Bloom: second canvas, blurred on top */
  #bloom {
    position: fixed; inset: 0; display: block;
    pointer-events: none;
    filter: blur(10px) brightness(2.8);
    opacity: 0.42;
    mix-blend-mode: screen;
  }

  /* Vignette overlay */
  #vignette {
    position: fixed; inset: 0; pointer-events: none; z-index: 5;
    background: radial-gradient(ellipse 70% 70% at 50% 50%, transparent 10%, #010508 100%);
  }

  /* Scanlines — heavier for a more oppressive feel */
  #scanlines {
    position: fixed; inset: 0; pointer-events: none; z-index: 6;
    background: repeating-linear-gradient(
      to bottom, transparent 0px, transparent 2px,
      rgba(0,0,0,0.18) 2px, rgba(0,0,0,0.18) 4px
    );
  }

  #headline {
    position: fixed; top: 1.5rem; left: 50%; transform: translateX(-50%);
    font-family: 'Cormorant Garamond', serif; font-weight: 300;
    font-size: 0.82rem; letter-spacing: 0.6em; text-transform: uppercase;
    color: #4aaa55; opacity: 0; z-index: 10;
    transition: opacity 1s ease;
    text-shadow: 0 0 30px rgba(40,160,60,0.5);
    white-space: nowrap;
  }
  #headline.on { opacity: 0.70; }

  #controls {
    position: fixed; bottom: 1.8rem; left: 50%; transform: translateX(-50%);
    display: flex; gap: 1rem; z-index: 10; opacity: 0;
    transition: opacity 0.8s ease 2s;
  }
  #controls.on { opacity: 1; }

  .btn {
    font-family: 'Share Tech Mono', monospace; font-size: 0.6rem;
    letter-spacing: 0.3em; text-transform: uppercase;
    color: #4aaa55; background: transparent;
    border: 1px solid rgba(50,160,70,0.22);
    padding: 0.45rem 0.9rem; cursor: pointer;
    transition: border-color 0.2s, box-shadow 0.2s;
  }
  .btn:hover { border-color: rgba(50,180,70,0.55); box-shadow: 0 0 12px rgba(30,140,50,0.2); }
  .btn.on { color: #aaffbb; border-color: #4aaa55; box-shadow: 0 0 16px rgba(40,160,60,0.35); }

  #gif-status {
    position: fixed; bottom: 4.5rem; left: 50%; transform: translateX(-50%);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.55rem; letter-spacing: 0.25em; color: #4aaa55;
    opacity: 0; z-index: 10; transition: opacity 0.3s; white-space: nowrap;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<canvas id="bloom"></canvas>
<div id="vignette"></div>
<div id="scanlines"></div>
<div id="headline">Resilience Stands</div>
<div id="controls">
  <button class="btn" id="btnAudio">♥ Heartbeat Off</button>
  <button class="btn" id="btnGif">⬇ Export GIF</button>
</div>
<div id="gif-status"></div>

<script>
'use strict';

// ─── CANVAS SETUP ────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const bloom  = document.getElementById('bloom');
const ctx    = canvas.getContext('2d');
const bctx   = bloom.getContext('2d');

const FONT_SIZE = 13;
const LINE_H    = FONT_SIZE * 1.56;
let   CHAR_W    = 8;

// Character sets — heavier, more angular and menacing
const DENSE = '█▓▓▒░▓█';
const MED   = '†‡×#@%▒';
const STAR  = '✦⊛◈☩✕⊕◈';
const LIGHT = '·:!|\\†+~^`×';

// ─── GEOMETRY ────────────────────────────────────────────────────────────────
let W, H, COLS, ROWS, CX, CY;
let cells = [];

function STAR_BASE() { return Math.min(W, H) * 0.30; }

function buildGeometry() {
  W = canvas.width  = bloom.width  = window.innerWidth;
  H = canvas.height = bloom.height = window.innerHeight;

  COLS = Math.ceil(W / CHAR_W) + 1;
  ROWS = Math.ceil(H / LINE_H) + 1;
  CX   = W / 2;
  CY   = H / 2;

  const BASE    = STAR_BASE();
  const OC      = BASE;
  const OD      = BASE;
  const INNER   = BASE * 0.28;
  const CENTER  = BASE * 0.08;
  const DIAMOND = BASE * 0.14;

  cells = [];
  for (let row = 0; row < ROWS; row++) {
    for (let col = 0; col < COLS; col++) {
      const px = col * CHAR_W + CHAR_W * 0.5 - CX;
      const py = row * LINE_H  + LINE_H  * 0.5 - CY;
      const dist  = Math.sqrt(px*px + py*py);
      const angle = Math.atan2(py, px);
      const deg   = ((angle * 180 / Math.PI) + 360) % 360;

      const toCard    = deg % 90 < 45 ? deg % 90 : 90 - deg % 90;
      const isCardinal = toCard < 22.5;

      const sF     = deg / 45;
      const sFloor = Math.floor(sF) % 8;
      const sFrac  = sF - Math.floor(sF);
      const tipA   = (sFloor % 2 === 0) ? OC : OD;
      const tipB   = ((sFloor+1) % 2 === 0) ? OC : OD;
      const starR  = sFrac < 0.5
        ? tipA  + (INNER - tipA)  * (1 - Math.cos(sFrac * 2 * Math.PI)) / 2
        : INNER + (tipB  - INNER) * (1 - Math.cos((sFrac-0.5)*2*Math.PI)) / 2;

      const orbitA = BASE * 1.35;
      const orbitB = BASE * 0.38;
      const ringThick = LINE_H * 1.4;

      function inOrbit(tiltDeg) {
        const tilt = tiltDeg * Math.PI / 180;
        const cos  = Math.cos(tilt), sin = Math.sin(tilt);
        const ex = px * cos + py * sin;
        const ey = -px * sin + py * cos;
        const ellipseVal = (ex/orbitA)**2 + (ey/orbitB)**2;
        const sqrtVal = Math.sqrt(ellipseVal);
        const arcDist = Math.abs(sqrtVal - 1) * Math.min(orbitA, orbitB);
        return arcDist < ringThick * 0.5;
      }

      const onOrbit2 = inOrbit(-30);

      // Compute parametric angle on the ellipse for animated ring drift
      let orbitT = 0;
      if (onOrbit2) {
        const tilt = -30 * Math.PI / 180;
        const cosT = Math.cos(tilt), sinT = Math.sin(tilt);
        const ex = px * cosT + py * sinT;
        const ey = -px * sinT + py * cosT;
        orbitT = Math.atan2(ey / orbitB, ex / orbitA);
      }

      // Stable per-cell random seed for background scatter
      const bgSeed = Math.sin(col * 127.1 + row * 311.7) * 43758.5453;
      const bgRand = bgSeed - Math.floor(bgSeed); // 0..1

      cells.push({
        px, py, dist, angle,
        starR, isCardinal,
        inStar:    dist < starR,
        inDiamond: dist < DIAMOND,
        inCenter:  dist < CENTER,
        inInner:   dist < INNER,
        onOrbit:   onOrbit2,
        orbitT,
        spawnT:    dist / BASE,
        bgRand
      });
    }
  }
}

// ─── FONT MEASUREMENT ────────────────────────────────────────────────────────
function measureFont(cb) {
  const tryMeasure = () => {
    const mc = document.createElement('canvas').getContext('2d');
    mc.font = `${FONT_SIZE}px "Share Tech Mono", monospace`;
    const w = mc.measureText('M').width;
    if (w > 5) { CHAR_W = w; cb(); }
    else setTimeout(tryMeasure, 50);
  };
  tryMeasure();
}

// ─── RIPPLES ─────────────────────────────────────────────────────────────────
const ripples = [];
const RIPPLE_SPEED = 350;
const RIPPLE_W     = 40;

function addRipple(isOrange) {
  const maxR = Math.sqrt(CX*CX + CY*CY) * 1.05;
  ripples.push({ t0: performance.now(), orange: isOrange, maxR });
}

function rippleColor(dist, nowMs) {
  let br=0, bg=0, bb=0, ba=0;
  for (let i = ripples.length-1; i >= 0; i--) {
    const rip  = ripples[i];
    const age  = (nowMs - rip.t0) * 0.001;
    const front = age * RIPPLE_SPEED;
    if (front > rip.maxR + RIPPLE_W) { ripples.splice(i,1); continue; }
    const diff = dist - front;
    if (diff > RIPPLE_W*0.25 || diff < -RIPPLE_W) continue;
    const norm = (diff + RIPPLE_W) / (RIPPLE_W * 1.25);
    const str  = Math.sin(Math.max(0, Math.min(1, norm)) * Math.PI);
    const prog = front / rip.maxR;
    const fade = prog < 0.88 ? 1 : Math.max(0, 1-(prog-0.88)/0.12);
    const s = str * fade;
    if (rip.orange) { br += s*220; bg += s*20;  bb += s*10;  }  // blood red
    else            { br += s*20;  bg += s*80;   bb += s*180; }  // cold ice blue
    ba = Math.max(ba, s * 0.72);
  }
  return [Math.min(255,br), Math.min(255,bg), Math.min(255,bb), Math.min(1,ba)];
}

// ─── HEARTBEAT AUDIO ─────────────────────────────────────────────────────────
let audioOn=false, audioCtx=null, nextBeat=0;
let droneNodes = null; // holds running drone oscillators

function startDrone(ac) {
  if (droneNodes) return;
  // Three layered oscillators: deep sub, mid, airy upper
  // Slight detuning creates a beating, breathing quality
  const masterGain = ac.createGain();
  masterGain.gain.setValueAtTime(0, ac.currentTime);
  masterGain.gain.linearRampToValueAtTime(0.022, ac.currentTime + 2.5); // fade in slowly
  masterGain.connect(ac.destination);

  // Low-pass filter to keep it dark and atmospheric
  const filter = ac.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 280;
  filter.Q.value = 1.2;
  filter.connect(masterGain);

  const freqs = [41, 55, 82, 61.5]; // sub, fundamental, octave, fifth — slightly detuned
  const gains = [0.5, 0.9, 0.4, 0.35];
  const oscs = freqs.map((f, i) => {
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = i === 0 ? 'sine' : 'sine';
    o.frequency.value = f;
    g.gain.value = gains[i];
    o.connect(g); g.connect(filter);
    o.start();
    return o;
  });

  // Slow LFO on master gain — breathes every ~7s
  const lfo = ac.createOscillator();
  const lfoGain = ac.createGain();
  lfo.frequency.value = 0.14;
  lfoGain.gain.value = 0.022;
  lfo.connect(lfoGain); lfoGain.connect(masterGain.gain);
  lfo.start();

  droneNodes = { oscs, lfo, masterGain };
}

function stopDrone() {
  if (!droneNodes) return;
  const now = audioCtx ? audioCtx.currentTime : 0;
  droneNodes.masterGain.gain.setValueAtTime(droneNodes.masterGain.gain.value, now);
  droneNodes.masterGain.gain.linearRampToValueAtTime(0, now + 1.8);
  setTimeout(() => {
    if (droneNodes) {
      droneNodes.oscs.forEach(o => { try { o.stop(); } catch(e){} });
      try { droneNodes.lfo.stop(); } catch(e){}
      droneNodes = null;
    }
  }, 2000);
}

function thud(ctx, when, freq, gain, dur) {
  const o=ctx.createOscillator(), e=ctx.createGain();
  o.connect(e); e.connect(ctx.destination);
  o.type='sine';
  o.frequency.setValueAtTime(freq,when);
  o.frequency.exponentialRampToValueAtTime(freq*0.28,when+dur);
  e.gain.setValueAtTime(0,when);
  e.gain.linearRampToValueAtTime(gain,when+0.01);
  e.gain.exponentialRampToValueAtTime(0.0001,when+dur);
  o.start(when); o.stop(when+dur+0.02);
}

function scheduleBeat() {
  if (!audioOn||!audioCtx) return;
  const now = audioCtx.currentTime;
  if (now >= nextBeat-0.05) {
    const t=nextBeat;
    thud(audioCtx,t,      85,0.18,0.28); thud(audioCtx,t,      50,0.12,0.32);
    thud(audioCtx,t+0.20, 70,0.11,0.22); thud(audioCtx,t+0.20, 42,0.08,0.26);
    const lubMs=Math.max(0,(t-now)*1000);
    const dubMs=Math.max(0,(t+0.20-now)*1000);
    setTimeout(()=>{ addRipple(true);  bumpScale(1.05,160); }, lubMs);
    setTimeout(()=>{ addRipple(false); bumpScale(1.02,120); }, dubMs);
    nextBeat = t+0.92;
  }
  setTimeout(scheduleBeat, 20);
}

document.getElementById('btnAudio').addEventListener('click', function() {
  audioOn=!audioOn;
  this.textContent = audioOn ? '♥ Heartbeat On' : '♥ Heartbeat Off';
  this.classList.toggle('on', audioOn);
  if (audioOn) {
    if (!audioCtx) audioCtx=new(window.AudioContext||window.webkitAudioContext)();
    nextBeat=audioCtx.currentTime+0.1;
    scheduleBeat();
    startDrone(audioCtx);
  } else {
    stopDrone();
  }
});

// ─── SCALE PULSE ─────────────────────────────────────────────────────────────
let scaleVal=1, scaleTarget=1;
function bumpScale(to, ms) {
  scaleTarget=to;
  setTimeout(()=>scaleTarget=1, ms);
}

// ─── MOUSE PARALLAX ──────────────────────────────────────────────────────────
let mouseX=0, mouseY=0;
document.addEventListener('mousemove', e=>{
  mouseX=(e.clientX/W-0.5)*2;
  mouseY=(e.clientY/H-0.5)*2;
});

// ─── HELPERS ─────────────────────────────────────────────────────────────────
function pick(str, n) {
  return str[((Math.floor(n)%str.length)+str.length)%str.length];
}

// ─── RENDER ──────────────────────────────────────────────────────────────────
let loadStart=null;
const FADEIN=2000;

let flickerSet=new Set(), flickerTimer=0;
let wOX=0,wOY=0,wOTX=0,wOTY=0,wOT=0;

function renderFrame(ts) {
  if (!loadStart) loadStart=ts;
  const fade = Math.min((ts-loadStart)/FADEIN, 1);
  const headlineEl = document.getElementById('headline');
  const controlsEl = document.getElementById('controls');
  if (fade>0.5 && !headlineEl.classList.contains('on')) {
    headlineEl.classList.add('on'); controlsEl.classList.add('on');
  }

  if (ts-wOT > 2500+Math.random()*2000) {
    wOT=ts;
    const a=Math.random()*Math.PI*2, r=15+Math.random()*30;
    wOTX=Math.cos(a)*r; wOTY=Math.sin(a)*r;
  }
  wOX+=(wOTX-wOX)*0.015; wOY+=(wOTY-wOY)*0.015;

  if (ts-flickerTimer > 1000+Math.random()*1500) {
    flickerTimer=ts; flickerSet.clear();
    if (Math.random()<0.5) {
      const n=Math.floor(Math.random()*2)+1;
      for(let i=0;i<n;i++) flickerSet.add(Math.floor(Math.random()*ROWS));
      setTimeout(()=>flickerSet.clear(), 60+Math.random()*80);
    }
  }

  scaleVal+=(scaleTarget-scaleVal)*0.2;

  const time  = ts * 0.001;
  const nowMs = performance.now();
  const tChar = Math.floor(time * 6) / 6;

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='#060d14';
  ctx.fillRect(0,0,W,H);
  bctx.clearRect(0,0,W,H);

  const tx = mouseX*7, ty = mouseY*4;
  ctx.save();
  ctx.translate(CX+tx, CY+ty);
  ctx.scale(scaleVal, scaleVal);
  ctx.translate(-CX, -CY);
  bctx.save();
  bctx.translate(CX+tx, CY+ty);
  bctx.scale(scaleVal, scaleVal);
  bctx.translate(-CX, -CY);

  const fontStr = `${FONT_SIZE}px "Share Tech Mono", monospace`;
  ctx.font = fontStr; ctx.textBaseline = 'top';
  bctx.font = fontStr; bctx.textBaseline = 'top';

  let curAlpha = -1;
  const setAlpha = (a) => {
    if (Math.abs(a - curAlpha) > 0.001) {
      ctx.globalAlpha = a; bctx.globalAlpha = a; curAlpha = a;
    }
  };

  const centerPulse = (Math.sin(time * 2.1) + 1) * 0.5;

  for (let row=0; row<ROWS; row++) {
    const isFlicker = flickerSet.has(row);
    const screenY   = row * LINE_H;

    for (let col=0; col<COLS; col++) {
      const cell = cells[row*COLS+col];
      if (!cell) continue;
      const { px, py, dist, angle, starR, isCardinal,
              inStar, inDiamond, inCenter, inInner,
              onOrbit, orbitIdx, spawnT } = cell;

      if (spawnT > fade * 2.2) continue;

      const screenX = col * CHAR_W;
      const [rr,rg,rb,ra] = rippleColor(dist, nowMs);
      const hasRipple = ra > 0.02;

      // ── ORBITAL RINGS ─────────────────────────────────────────
      if (onOrbit && !inStar) {
        // Characters drift along the ellipse — orbitT is the parametric angle,
        // subtracting time*speed makes them flow around the ellipse.
        const ORBIT_SPEED = 0.38;
        const phase = cell.orbitT - time * ORBIT_SPEED;

        // Density wave: chars cluster then thin out as they orbit
        const densityWave = (Math.sin(phase * 2.0 + time * 0.5) + 1) * 0.5;
        const orbitChars = densityWave > 0.55 ? '─━—' : densityWave > 0.25 ? '·•·' : '  ·';
        const charIdx = ((phase * 4.0) % orbitChars.length + orbitChars.length) % orbitChars.length;
        const orbitChar = orbitChars[Math.floor(charIdx)];

        // Bright white with very faint cool tint — clearly distinct from the green star
        const orbitBright = 0.45 + 0.45 * densityWave + 0.12 * Math.sin(time * 1.1 + cell.orbitT * 3);
        const ov = 220 * orbitBright | 0;
        const og = 235 * orbitBright | 0;
        const ob = 225 * orbitBright | 0;
        const alpha = isFlicker ? 0.04 : orbitBright * 0.88;
        setAlpha(alpha);
        ctx.fillStyle  = `rgb(${ov},${og},${ob})`;
        bctx.fillStyle = `rgb(${ov},${og},${ob})`;
        ctx.fillText(orbitChar, screenX, screenY);
        bctx.fillText(orbitChar, screenX, screenY);
        continue;
      }

      // ── OUTSIDE STAR (no orbit) ───────────────────────────────
      if (!inStar) {
        // Background scatter layer — faint chars seeded per cell
        if (!hasRipple) {
          // Only ~10% of bg cells show a char; they drift/flicker slowly
          if (cell.bgRand < 0.10) {
            const bgPhase  = time * 0.18 + cell.bgRand * 99.1;
            const bgBlink  = (Math.sin(bgPhase) + 1) * 0.5;
            if (bgBlink > 0.35) {
              const bgAlpha = bgBlink * 0.11 * (1 - Math.min(cell.dist / (Math.min(W,H)*0.7), 1));
              if (bgAlpha > 0.01) {
                const bgChar = pick('·:†×·+·', cell.bgRand * 13 + Math.floor(time * 0.3));
                setAlpha(bgAlpha);
                // Cold blue-green — like something watching from the dark
                ctx.fillStyle = 'rgb(40,90,110)';
                bctx.fillStyle = 'rgb(40,90,110)';
                ctx.fillText(bgChar, screenX, screenY);
                bctx.fillText(bgChar, screenX, screenY);
              }
            }
          }
          continue;
        }
        const alpha = isFlicker ? ra*0.05 : ra * 0.72;
        setAlpha(alpha);
        const colStr = `rgb(${rr|0},${rg|0},${rb|0})`;
        ctx.fillStyle = colStr; bctx.fillStyle = colStr;
        const char = pick(LIGHT, tChar*2.5 + dist*0.008 + angle);
        ctx.fillText(char, screenX, screenY);
        bctx.fillText(char, screenX, screenY);
        continue;
      }

      // ── INSIDE STAR ──────────────────────────────────────────
      const wdx = px - wOX, wdy = py - wOY;
      const wd  = Math.sqrt(wdx*wdx+wdy*wdy);
      const wa  = Math.atan2(wdy, wdx);

      const w1 = Math.sin(time*0.9 + wd*0.010 + wa*2.0);
      const w2 = Math.sin(time*0.5 - wd*0.012 + wa*1.7);
      const w3 = Math.sin(time*1.4 + wa*2.5   - wd*0.008);
      const wN = ((w1*0.6 + w2*0.3 + w3*0.1) + 1) * 0.5;

      let char, rv, gv, bv;

      if (inCenter) {
        const pulse2 = (Math.sin(time * 3.2 + dist * 0.1) + 1) * 0.5;
        const RUBY = STAR_BASE() * 0.035; // tiny yellow ruby zone inside the green center
        if (dist < RUBY) {
          // ── RUBY CORE: sharp vivid yellow diamond ────────────
          rv = 220 + pulse2 * 35 | 0;
          gv = 200 + pulse2 * 55 | 0;
          bv =   5 + pulse2 * 10 | 0;
          char = pick('◇◈◇', tChar * 3.0 + angle);
        } else {
          // ── CENTER RING: cold toxic green ────────────────────
          rv =  10 + pulse2 * 20 | 0;
          gv = 160 + pulse2 * 90 | 0;
          bv =  10 + pulse2 * 25 | 0;
          char = pick('⊕◈⊛⊕', tChar * 2.5 + angle);
        }

      } else if (inDiamond) {
        // ── DIAMOND RING: toxic green surrounding center ──────
        const pulse2 = (Math.sin(time * 2.2 + dist * 0.08) + 1) * 0.5;
        rv =  5 + pulse2 * 20 | 0;
        gv = 120 + pulse2 * 100 | 0;
        bv =  5 + pulse2 * 15  | 0;
        char = pick('·⊛:·', tChar * 2.0 + angle * 2);

      } else if (inInner) {
        // ── INNER BODY: black void with toxic green pulse ─────
        const blend = (Math.sin(time*1.1 + angle*2.5 + dist*0.018) + 1) * 0.5;
        // Mostly black with violent green flashes — like a wounded thing
        rv =  3 + blend * 12  | 0;
        gv = 30 + blend * 140 | 0;
        bv =  5 + blend * 18  | 0;
        char = wN > 0.7 ? pick(DENSE, tChar*1.8 + dist*0.005 + angle)
             : wN > 0.4 ? pick(MED,   tChar*1.4 + dist*0.005)
             :              pick(STAR,  tChar*1.0 + angle);

      } else if (isCardinal) {
        // ── CARDINAL SPIKES: poison green, visible to the tips ─
        const tf = dist / starR;
        const i2 = wN * (1 - tf * 0.55);
        rv =  2 + i2 * 10   + w2 * 3  | 0;
        gv = 60 + i2 * 185  + w1 * 35 | 0;  // 60 base ensures tips stay visible
        bv =  2 + i2 * 12   + w3 * 5  | 0;
        const cT = tChar * 1.6;
        char = tf < 0.25 ? (i2>0.5 ? pick(DENSE, cT+dist*0.004+angle) : pick(MED, cT+dist*0.004))
             : tf < 0.6  ? (i2>0.35 ? pick(MED,   cT+dist*0.004)       : pick(LIGHT, cT+dist*0.004+angle))
             : pick(LIGHT, cT + angle*5 + dist*0.004);

      } else {
        // ── DIAGONAL SPIKES: vivid yellow ─────────────────────
        const tf = dist / starR;
        const i2 = wN * (1 - tf * 0.55);
        rv = 180 + i2 * 75  + w1 * 15 | 0;   // strong yellow-red
        gv = 160 + i2 * 90  + w2 * 15 | 0;   // strong yellow-green
        bv =   0 + i2 * 5   + w3 * 2  | 0;   // near-zero blue = pure yellow
        const cT = tChar * 1.8;
        char = tf < 0.35 ? (i2>0.55 ? pick(DENSE, cT+dist*0.005+angle) : pick(MED, cT+dist*0.005))
             : tf < 0.7  ? (i2>0.45 ? pick(MED,   cT+dist*0.005)       : pick(STAR, tChar+dist*0.005))
             : (i2>0.35  ? pick(STAR, tChar+dist*0.005+angle)           : pick(LIGHT, cT+dist*0.005));
      }

      // Ripple tint
      if (hasRipple) {
        rv = Math.min(255, rv + (rr*0.45|0));
        gv = Math.min(255, gv + (rg*0.45|0));
        bv = Math.min(255, bv + (rb*0.45|0));
      }

      rv = Math.max(0, Math.min(255, rv));
      gv = Math.max(0, Math.min(255, gv));
      bv = Math.max(0, Math.min(255, bv));

      setAlpha(isFlicker ? 0.07 : 1.0);
      const colStr = `rgb(${rv},${gv},${bv})`;
      ctx.fillStyle = colStr; bctx.fillStyle = colStr;
      ctx.fillText(char, screenX, screenY);
      bctx.fillText(char, screenX, screenY);
    }
  }

  ctx.globalAlpha = 1; bctx.globalAlpha = 1;
  ctx.restore();
  bctx.restore();

  if (pendingSnapshot) {
    const fn = pendingSnapshot;
    pendingSnapshot = null;
    fn();
  }

  requestAnimationFrame(renderFrame);
}

// ─── RESIZE ──────────────────────────────────────────────────────────────────
function onResize() { buildGeometry(); }
window.addEventListener('resize', onResize);

// ─── BOOT ────────────────────────────────────────────────────────────────────
measureFont(() => {
  buildGeometry();
  requestAnimationFrame(renderFrame);
});

let pendingSnapshot = null;

// ─── GIF EXPORT — PERFECT LOOP DETECTION ─────────────────────────────────────
// Strategy:
//   1. Snapshot frame 0 the instant Export is clicked.
//   2. Build a small fingerprint (32×32 luminance) of frame 0.
//   3. Keep running the live animation, capturing full-res frames every GIF_DELAY_MS.
//   4. After a minimum search window, compare each new frame's fingerprint to frame 0.
//   5. Track the best match (lowest MSE). Stop early if match is near-perfect.
//   6. After max search time, use the best-match frame as the loop end point.
//   7. Export frames 0 → best-match — no crossfade, no faking: genuine loop.

const btnGif    = document.getElementById('btnGif');
const gifStatus = document.getElementById('gif-status');
let isExporting  = false;

const GIF_DELAY_MS  = 50;   // 20fps playback
const GIF_SCALE     = 0.5;  // half-res output
const FP_SIZE       = 32;   // fingerprint canvas dimension (32×32 = 1024 pixels)
const SEARCH_MIN_MS = 2000; // don't accept a match in the first 2s (too close to frame 0)
const SEARCH_MAX_MS = 25000;// give up searching after 25s and use best found
const EARLY_STOP_MSE = 18;  // if MSE drops below this, accept immediately — near-perfect

function captureNextFrame() {
  return new Promise(resolve => { pendingSnapshot = resolve; });
}

// Build a luminance fingerprint of a canvas at FP_SIZE × FP_SIZE
function fingerprint(srcCanvas) {
  const fp = document.createElement('canvas');
  fp.width = fp.height = FP_SIZE;
  fp.getContext('2d').drawImage(srcCanvas, 0, 0, FP_SIZE, FP_SIZE);
  const data = fp.getContext('2d').getImageData(0, 0, FP_SIZE, FP_SIZE).data;
  const lum  = new Float32Array(FP_SIZE * FP_SIZE);
  for (let i = 0; i < lum.length; i++) {
    // Perceptual luminance
    lum[i] = data[i*4]*0.299 + data[i*4+1]*0.587 + data[i*4+2]*0.114;
  }
  return lum;
}

// Mean squared error between two luminance arrays
function mse(a, b) {
  let s = 0;
  for (let i = 0; i < a.length; i++) { const d = a[i]-b[i]; s += d*d; }
  return s / a.length;
}

// Clone a canvas to a new canvas of the same size
function cloneCanvas(src) {
  const dst = document.createElement('canvas');
  dst.width = src.width; dst.height = src.height;
  dst.getContext('2d').drawImage(src, 0, 0);
  return dst;
}

btnGif.addEventListener('click', async () => {
  if (isExporting) return;
  isExporting = true;
  btnGif.classList.add('on');
  gifStatus.style.opacity = '1';

  const GW = Math.round(W * GIF_SCALE);
  const GH = Math.round(H * GIF_SCALE);

  // Scratch canvas for scaling
  const scratch = document.createElement('canvas');
  scratch.width = GW; scratch.height = GH;
  const sc = scratch.getContext('2d');

  // ── PHASE 1: capture frame 0 immediately ──────────────────────────────────
  gifStatus.textContent = 'Locking frame 0…';
  await captureNextFrame();

  sc.clearRect(0, 0, GW, GH);
  sc.drawImage(canvas, 0, 0, GW, GH);
  const frame0 = cloneCanvas(scratch);
  const fp0    = fingerprint(frame0);
  const frames = [frame0]; // will accumulate all frames

  // ── PHASE 2: search for the matching frame ────────────────────────────────
  // We capture every GIF_DELAY_MS and compare. Track best match index + score.
  let bestMatchIdx  = -1;
  let bestMatchMSE  = Infinity;
  const searchStart = performance.now();
  let   found       = false;

  gifStatus.textContent = 'Searching for loop point…';

  while (!found) {
    const elapsed = performance.now() - searchStart;

    // Hard timeout
    if (elapsed > SEARCH_MAX_MS) break;

    // Wait for next rendered frame then the inter-frame gap
    await captureNextFrame();
    await new Promise(r => setTimeout(r, GIF_DELAY_MS));

    // Capture this frame
    sc.clearRect(0, 0, GW, GH);
    sc.drawImage(canvas, 0, 0, GW, GH);
    const frameN = cloneCanvas(scratch);
    frames.push(frameN);

    const frameIdx = frames.length - 1;

    // Only start comparing after the minimum window
    if (elapsed >= SEARCH_MIN_MS) {
      const score = mse(fingerprint(frameN), fp0);

      const elapsedS  = (elapsed / 1000).toFixed(1);
      const maxS      = (SEARCH_MAX_MS / 1000).toFixed(0);
      const mseStr    = score.toFixed(1);
      gifStatus.textContent =
        `Searching ${elapsedS}s / ${maxS}s  —  best Δ ${
          bestMatchMSE === Infinity ? '—' : bestMatchMSE.toFixed(1)
        }  current Δ ${mseStr}`;

      if (score < bestMatchMSE) {
        bestMatchMSE = score;
        bestMatchIdx = frameIdx;
      }

      // Early-stop: close enough to be a perfect loop
      if (score <= EARLY_STOP_MSE) {
        found = true;
      }
    } else {
      const elapsedS = (elapsed / 1000).toFixed(1);
      const minS     = (SEARCH_MIN_MS / 1000).toFixed(0);
      gifStatus.textContent = `Warming up ${elapsedS}s / ${minS}s…`;
    }
  }

  // Trim frames to the best match (inclusive of the loop frame)
  // The loop is: frames[0] → frames[bestMatchIdx]
  // frames[bestMatchIdx] is NOT included in the GIF because when the GIF loops
  // back to frame 0, it already looks like that frame — true seamless loop.
  const loopFrames = frames.slice(0, bestMatchIdx); // exclude the match frame itself

  const frameCount = loopFrames.length;
  const durationS  = (frameCount * GIF_DELAY_MS / 1000).toFixed(2);
  gifStatus.textContent =
    `Found loop at frame ${bestMatchIdx} (${durationS}s, Δ ${bestMatchMSE.toFixed(1)}) — quantizing…`;
  await new Promise(r => setTimeout(r, 40));

  // ── PHASE 3: encode ──────────────────────────────────────────────────────
  try {
    const bytes = encodeGIF(loopFrames, GIF_DELAY_MS);
    const blob  = new Blob([bytes], { type: 'image/gif' });
    const url   = URL.createObjectURL(blob);
    const a     = document.createElement('a');
    a.href = url; a.download = 'resilience-stands.gif';
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url);
    gifStatus.textContent = `✓ ${frameCount} frames, ${durationS}s perfect loop!`;
    setTimeout(resetExport, 2500);
  } catch(e) {
    console.error(e);
    gifStatus.textContent = 'Encode error — saving PNG…';
    loopFrames[0].toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'resilience-stands.png';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
      setTimeout(resetExport, 1200);
    });
  }
});

function resetExport() {
  isExporting = false;
  btnGif.classList.remove('on');
  btnGif.textContent = '⬇ Export GIF';
  gifStatus.style.opacity = '0';
}

// ─── GIF ENCODER WITH MEDIAN-CUT QUANTIZER ───────────────────────────────────
function encodeGIF(canvases, delayMs) {
  const W2 = canvases[0].width, H2 = canvases[0].height;
  const delay = Math.round(delayMs / 10);

  // ── MEDIAN-CUT: sample colors from all frames, build 255-color palette ──
  // Sample every Nth pixel across all frames to keep it fast
  const PALETTE_SIZE = 255; // leave 1 slot for transparent/black
  const allPixels = [];
  const sampleStep = Math.max(1, Math.floor((W2 * H2 * canvases.length) / 18000));

  for (const cv of canvases) {
    const data = cv.getContext('2d').getImageData(0, 0, W2, H2).data;
    for (let i = 0; i < W2 * H2; i += sampleStep) {
      allPixels.push([data[i*4], data[i*4+1], data[i*4+2]]);
    }
  }

  // Median-cut: recursively split buckets by widest channel range
  function medianCut(pixels, depth) {
    if (depth === 0 || pixels.length === 0) {
      if (pixels.length === 0) return [[0,0,0]];
      // Average the bucket
      let sr=0,sg=0,sb=0;
      for (const [r,g,b] of pixels) { sr+=r; sg+=g; sb+=b; }
      const n = pixels.length;
      return [[sr/n|0, sg/n|0, sb/n|0]];
    }
    // Find channel with max range
    let minR=255,maxR=0,minG=255,maxG=0,minB=255,maxB=0;
    for (const [r,g,b] of pixels) {
      if(r<minR)minR=r; if(r>maxR)maxR=r;
      if(g<minG)minG=g; if(g>maxG)maxG=g;
      if(b<minB)minB=b; if(b>maxB)maxB=b;
    }
    const rng = [maxR-minR, maxG-minG, maxB-minB];
    const ch  = rng[0]>=rng[1] && rng[0]>=rng[2] ? 0 : rng[1]>=rng[2] ? 1 : 2;
    // Sort by that channel and split at median
    pixels.sort((a,b) => a[ch]-b[ch]);
    const mid = pixels.length >> 1;
    return [
      ...medianCut(pixels.slice(0, mid), depth - 1),
      ...medianCut(pixels.slice(mid),    depth - 1)
    ];
  }

  // depth = log2(PALETTE_SIZE) ≈ 8 → 256 colors, cap at 255
  const rawPal = medianCut(allPixels, 8).slice(0, PALETTE_SIZE);
  // Pad to exactly 256
  while (rawPal.length < 256) rawPal.push([0,0,0]);
  const pal = rawPal; // [[r,g,b], ...]

  // Nearest-color cache using quantized key
  const nc = new Map();
  function nearestIdx(r, g, b) {
    const k = (r>>1)<<14 | (g>>1)<<7 | (b>>1);
    if (nc.has(k)) return nc.get(k);
    let best=0, bd=1e9;
    for (let i=0; i<pal.length; i++) {
      const dr=r-pal[i][0], dg=g-pal[i][1], db=b-pal[i][2];
      // Perceptual weighting: green matters most
      const d = dr*dr*0.299 + dg*dg*0.587 + db*db*0.114;
      if (d < bd) { bd=d; best=i; if(d===0) break; }
    }
    nc.set(k, best);
    return best;
  }

  // ── GIF BYTE STREAM ──────────────────────────────────────────────────────
  const by = [];
  const p  = (...a) => { for (const x of a) by.push(x); };
  const pw = n => { p(n & 255, (n >> 8) & 255); };
  const ps = s => { for (const c of s) p(c.charCodeAt(0)); };

  ps('GIF89a'); pw(W2); pw(H2);
  p(0xF7, 0, 0); // global color table flag, 256 colors
  for (let i=0; i<256; i++) p(pal[i][0], pal[i][1], pal[i][2]);
  p(0x21, 0xFF, 0x0B); ps('NETSCAPE2.0'); p(0x03, 0x01, 0x00, 0x00, 0x00);

  for (const cv of canvases) {
    const img = cv.getContext('2d').getImageData(0, 0, W2, H2).data;
    const idx = new Uint8Array(W2 * H2);
    for (let i=0; i<W2*H2; i++) {
      idx[i] = nearestIdx(img[i*4], img[i*4+1], img[i*4+2]);
    }
    p(0x21, 0xF9, 0x04, 0x00); pw(delay); p(0x00, 0x00);
    p(0x2C); pw(0); pw(0); pw(W2); pw(H2); p(0x00);
    const lzw = lzwEnc(idx, 8);
    p(8);
    for (let i=0; i<lzw.length; i+=255) {
      const ch = lzw.slice(i, i+255);
      p(ch.length, ...ch);
    }
    p(0x00);
  }
  p(0x3B);
  return new Uint8Array(by);
}

function lzwEnc(idx,mb){
  const cc=1<<mb,eof=cc+1;
  const out=[];let buf=0,bits=0,cs=mb+1,next=eof+1;
  const t=new Map();
  const emit=c=>{buf|=(c<<bits);bits+=cs;while(bits>=8){out.push(buf&255);buf>>>=8;bits-=8;}};
  const rst=()=>{t.clear();next=eof+1;cs=mb+1;};
  emit(cc);rst();
  let pf=idx[0];
  for(let i=1;i<idx.length;i++){
    const s=idx[i],k=(pf<<8)|s,f=t.get(k);
    if(f!==undefined){pf=f;}
    else{emit(pf);if(next<4096){t.set(k,next++);if(next>(1<<cs)&&cs<12)cs++;}else{emit(cc);rst();}pf=s;}
  }
  emit(pf);emit(eof);if(bits>0)out.push(buf&255);
  return out;
}
</script>
</body>
</html>
